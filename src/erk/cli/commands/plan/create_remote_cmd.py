"""Trigger remote planning workflow with a prompt."""

import subprocess
from datetime import UTC, datetime
from pathlib import Path

import click
from erk_shared.github.metadata import format_plan_content_comment, format_plan_header_body
from erk_shared.naming import sanitize_worktree_name
from erk_shared.output.output import user_output

from erk.cli.core import discover_repo_context
from erk.core.context import ErkContext

# Placeholder content shown while remote planning is in progress
PENDING_PLAN_CONTENT = """# Plan: Pending Remote Generation

This plan is currently being generated by a GitHub Actions workflow.

The plan content will be updated automatically when the workflow completes.

**Status:** â³ Planning in progress...
"""


@click.command("create-remote")
@click.argument("prompt_file", type=click.Path(exists=True))
@click.option("--title", "-t", type=str, help="Issue title (default: derived from prompt)")
@click.pass_obj
def create_remote_cmd(ctx: ErkContext, prompt_file: str, title: str | None) -> None:
    """Trigger remote planning workflow with a prompt file.

    Creates a placeholder issue immediately for tracking, then triggers
    a GitHub Actions workflow to generate the plan asynchronously.
    The issue will be updated when planning completes.

    PROMPT_FILE: Path to file containing the planning prompt.
    """
    repo = discover_repo_context(ctx, ctx.cwd)
    repo_root = repo.root

    # Read prompt from file
    prompt_path = Path(prompt_file)
    prompt = prompt_path.read_text(encoding="utf-8").strip()

    if not prompt:
        user_output(click.style("Error: ", fg="red") + "Prompt file is empty")
        raise SystemExit(1)

    # Get GitHub username
    submitted_by = _get_github_username()

    # Derive title from prompt if not provided
    if title is None:
        # Use first line of prompt, truncated
        first_line = prompt.split("\n")[0].strip()
        # Remove common prefixes
        for prefix in ["implement ", "add ", "create ", "build "]:
            if first_line.lower().startswith(prefix):
                first_line = first_line[len(prefix) :]
                break
        # Capitalize and truncate
        title = first_line[:80].strip()
        if len(first_line) > 80:
            title = title + "..."
        # Fallback if empty
        if not title:
            title = "Remote Plan (Pending)"

    user_output(f"Creating placeholder issue: {title}")
    user_output("")

    # Ensure erk-plan label exists
    try:
        ctx.issues.ensure_label_exists(
            repo_root,
            label="erk-plan",
            description="Implementation plan tracked by erk",
            color="0E8A16",  # Green
        )
    except RuntimeError as e:
        user_output(click.style("Error: ", fg="red") + f"Failed to ensure label exists: {e}")
        raise SystemExit(1) from e

    # Create timestamp and worktree name
    timestamp = datetime.now(UTC).isoformat()
    worktree_name = sanitize_worktree_name(title)

    # Format issue body (Schema V2: metadata only)
    issue_body = format_plan_header_body(
        created_at=timestamp,
        created_by=submitted_by,
        worktree_name=worktree_name,
    )

    # Create the placeholder issue
    try:
        result = ctx.issues.create_issue(
            repo_root=repo_root,
            title=title,
            body=issue_body,
            labels=["erk-plan"],
        )
    except RuntimeError as e:
        user_output(click.style("Error: ", fg="red") + f"Failed to create issue: {e}")
        raise SystemExit(1) from e

    # Add placeholder plan content as first comment
    try:
        comment_body = format_plan_content_comment(PENDING_PLAN_CONTENT)
        ctx.issues.add_comment(repo_root, result.number, comment_body)
    except RuntimeError as e:
        user_output(
            click.style("Warning: ", fg="yellow")
            + f"Issue created but failed to add placeholder comment: {e}"
        )

    user_output(click.style("Created: ", fg="green") + f"Issue #{result.number}")
    user_output(f"  URL: {result.url}")
    user_output("")

    # Trigger workflow with issue number
    user_output("Triggering remote planning workflow...")
    user_output(f"  Prompt: {prompt[:100]}{'...' if len(prompt) > 100 else ''}")
    user_output("")

    try:
        run_id = ctx.github.trigger_workflow(
            repo_root=repo_root,
            workflow="plan-create.yml",
            inputs={
                "prompt": prompt,
                "submitted_by": submitted_by,
                "issue_number": str(result.number),
            },
        )
    except RuntimeError as e:
        user_output(click.style("Error: ", fg="red") + str(e))
        raise SystemExit(1) from e

    # Construct workflow URL
    workflow_url = f"https://github.com/{repo.repo_name}/actions/runs/{run_id}"

    user_output(click.style("Success: ", fg="green") + "Planning workflow triggered!")
    user_output("")
    user_output("Next steps:")
    user_output(f"  - Track issue: {result.url}")
    user_output(f"  - View workflow: {workflow_url}")
    user_output("  - The issue will be updated when planning completes")


def _get_github_username() -> str:
    """Get current GitHub username via gh CLI."""
    try:
        result = subprocess.run(
            ["gh", "api", "user", "--jq", ".login"],
            capture_output=True,
            text=True,
            check=True,
        )
        username = result.stdout.strip()
        if username:
            return username
        return "unknown"
    except subprocess.CalledProcessError:
        return "unknown"
