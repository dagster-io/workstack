"""Tests for submit_branch kit CLI command using fake ops."""

import json
from collections.abc import Generator
from pathlib import Path
from unittest.mock import Mock, patch

import pytest
from click.testing import CliRunner

from erk.data.kits.gt.kit_cli_commands.gt.submit_branch import (
    PostAnalysisError,
    PostAnalysisResult,
    PreAnalysisError,
    PreAnalysisResult,
    build_pr_metadata_section,
    execute_post_analysis,
    execute_pre_analysis,
    submit_pr,
)
from tests.unit.kits.gt.fake_ops import FakeGtKitOps

# Patch path for RealGitHub mock (patch where it's defined, not where it's imported)
GITHUB_PATCH_PATH = "erk_shared.github.real.RealGitHub"


@pytest.fixture
def runner() -> CliRunner:
    """Create a Click CLI test runner."""
    return CliRunner()


@pytest.fixture(autouse=True)
def mock_github() -> Generator[Mock]:
    """Mock RealGitHub to prevent NotImplementedError from erk-shared stub."""
    with patch(GITHUB_PATCH_PATH) as mock_github_class:
        mock_github = mock_github_class.return_value
        # Default: return no PR (allows tests to proceed with normal flow)
        mock_pr_info = Mock()
        mock_pr_info.pr_number = None
        mock_pr_info.url = None
        mock_github.get_pr_status.return_value = mock_pr_info
        yield mock_github


class TestBuildPRMetadataSection:
    """Tests for build_pr_metadata_section() function."""

    def test_build_metadata_with_all_fields(self, tmp_path: Path) -> None:
        """Test building metadata section with all fields (issue, author, run info)."""
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()

        # Create issue.json
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/repo/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}',
            encoding="utf-8",
        )

        # Create plan.md with author
        plan_md = impl_dir / "plan.md"
        plan_md.write_text(
            """<!-- erk:metadata-block:plan-header -->
<details>
<summary><code>plan-header</code></summary>

```yaml

schema_version: '2'
created_at: '2025-01-15T10:00:00+00:00'
created_by: testuser
worktree_name: test-worktree

```

</details>
<!-- /erk:metadata-block:plan-header -->

# Plan
""",
            encoding="utf-8",
        )

        # Create run-info.json
        run_info_json = impl_dir / "run-info.json"
        run_info_json.write_text(
            '{"run_id": "12345678901", '
            '"run_url": "https://github.com/repo/actions/runs/12345678901"}',
            encoding="utf-8",
        )

        result = build_pr_metadata_section(impl_dir, pr_number=456)

        assert "This PR was generated by an agent in the `erk` queue." in result
        assert "- **Plan:** [#123](https://github.com/repo/issues/123)" in result
        assert "- **Plan Author:** @testuser" in result
        assert (
            "- **GitHub Action:** [View Run](https://github.com/repo/actions/runs/12345678901)"
            in result
        )
        assert "erk pr checkout 456" in result
        assert "Closes #123" in result
        assert "---" in result

    def test_build_metadata_with_placeholder(self, tmp_path: Path) -> None:
        """Test building metadata section with PR number placeholder."""
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()

        # Create issue.json
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 789, "issue_url": "https://github.com/repo/issues/789", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}',
            encoding="utf-8",
        )

        result = build_pr_metadata_section(impl_dir, pr_number=None)

        assert "erk pr checkout __PLACEHOLDER_PR_NUMBER__" in result
        assert "Closes #789" in result

    def test_build_metadata_empty_when_no_metadata_files(self, tmp_path: Path) -> None:
        """Test that empty string is returned when no metadata files exist."""
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()

        result = build_pr_metadata_section(impl_dir, pr_number=456)

        assert result == ""

    def test_build_metadata_only_issue_reference(self, tmp_path: Path) -> None:
        """Test building metadata with only issue reference."""
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()

        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 999, "issue_url": "https://github.com/repo/issues/999", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}',
            encoding="utf-8",
        )

        result = build_pr_metadata_section(impl_dir, pr_number=100)

        assert "This PR was generated by an agent in the `erk` queue." in result
        assert "- **Plan:** [#999](https://github.com/repo/issues/999)" in result
        assert "- **Plan Author:**" not in result
        assert "- **GitHub Action:**" not in result
        assert "erk pr checkout 100" in result
        assert "Closes #999" in result

    def test_build_metadata_only_plan_author(self, tmp_path: Path) -> None:
        """Test building metadata with only plan author."""
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()

        plan_md = impl_dir / "plan.md"
        plan_md.write_text(
            """<!-- erk:metadata-block:plan-header -->
<details>
<summary><code>plan-header</code></summary>

```yaml

schema_version: '2'
created_at: '2025-01-15T10:00:00+00:00'
created_by: solo-author
worktree_name: test-worktree

```

</details>
<!-- /erk:metadata-block:plan-header -->

# Plan
""",
            encoding="utf-8",
        )

        result = build_pr_metadata_section(impl_dir, pr_number=200)

        assert "This PR was generated by an agent in the `erk` queue." in result
        assert "- **Plan Author:** @solo-author" in result
        assert "- **Plan:**" not in result
        assert "Closes #" not in result
        assert "erk pr checkout 200" in result


class TestPreAnalysisExecution:
    """Tests for pre-analysis phase execution logic."""

    def test_pre_analysis_with_uncommitted_changes(self) -> None:
        """Test pre-analysis when uncommitted changes exist (should commit them)."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_uncommitted_files(["file.txt"])
            .with_commits(0)  # Start with no commits
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisResult)
        assert result.success is True
        assert result.branch_name == "feature-branch"
        assert result.uncommitted_changes_committed is True
        assert "Committed uncommitted changes" in result.message
        # After commit, should have 1 commit
        assert ops.git().count_commits_in_branch("main") == 1

    def test_pre_analysis_without_uncommitted_changes(self) -> None:
        """Test pre-analysis when no uncommitted changes exist."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)  # Single commit, no uncommitted files
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisResult)
        assert result.success is True
        assert result.uncommitted_changes_committed is False
        assert result.commit_count == 1
        assert result.squashed is False
        assert "Single commit, no squash needed" in result.message

    def test_pre_analysis_with_multiple_commits(self) -> None:
        """Test pre-analysis with 2+ commits (should squash)."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(3)  # Multiple commits
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisResult)
        assert result.success is True
        assert result.commit_count == 3
        assert result.squashed is True
        assert "Squashed 3 commits into 1" in result.message

    def test_pre_analysis_single_commit(self) -> None:
        """Test pre-analysis with single commit (no squash needed)."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)  # Single commit
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisResult)
        assert result.success is True
        assert result.commit_count == 1
        assert result.squashed is False
        assert "Single commit, no squash needed" in result.message

    def test_pre_analysis_no_branch(self) -> None:
        """Test error when current branch cannot be determined."""
        ops = FakeGtKitOps()
        # Set current_branch to None to simulate failure
        from dataclasses import replace

        ops.git()._state = replace(ops.git().get_state(), current_branch="")

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.success is False
        assert result.error_type == "no_branch"
        assert "Could not determine current branch" in result.message

    def test_pre_analysis_no_parent(self) -> None:
        """Test error when parent branch cannot be determined."""
        ops = FakeGtKitOps().with_branch("orphan-branch", parent="main")
        # Remove parent relationship to simulate gt parent failure
        from dataclasses import replace

        gt_state = ops.graphite().get_state()
        ops.graphite()._state = replace(gt_state, branch_parents={})

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.success is False
        assert result.error_type == "no_parent"
        assert "Could not determine parent branch" in result.message

    def test_pre_analysis_no_commits(self) -> None:
        """Test error when branch has no commits."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(0)  # No commits
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.success is False
        assert result.error_type == "no_commits"
        assert "No commits found in branch" in result.message

    def test_pre_analysis_squash_fails(self) -> None:
        """Test error when gt squash fails."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(3)  # Multiple commits to trigger squash
            .with_squash_failure()  # Configure squash to fail
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.success is False
        assert result.error_type == "squash_failed"
        assert "Failed to squash commits" in result.message

    def test_pre_analysis_detects_squash_conflict(self) -> None:
        """Test that squash conflicts are detected and reported correctly."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(3)  # Multiple commits to trigger squash
            .with_squash_failure(
                stdout="",
                stderr=(
                    "error: could not apply abc123... commit message\n"
                    "CONFLICT (content): Merge conflict in file.txt"
                ),
            )
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.success is False
        assert result.error_type == "squash_conflict"
        assert "Merge conflicts detected while squashing commits" in result.message
        stderr = result.details["stderr"]
        assert isinstance(stderr, str)
        assert "CONFLICT" in stderr

    def test_pre_analysis_squash_conflict_preserves_output(self) -> None:
        """Test that conflict errors include stdout/stderr for debugging."""
        test_stdout = "Some output"
        test_stderr = "CONFLICT (content): Merge conflict in README.md"

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(2)
            .with_squash_failure(stdout=test_stdout, stderr=test_stderr)
        )

        result = execute_pre_analysis(ops)

        assert isinstance(result, PreAnalysisError)
        assert result.error_type == "squash_conflict"
        assert result.details["stdout"] == test_stdout
        assert result.details["stderr"] == test_stderr
        assert result.details["branch_name"] == "feature-branch"

    def test_pre_analysis_detects_pr_conflicts_from_github(self) -> None:
        """Test that PR conflicts are detected before any work is done."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="master").with_commits(1)

        # Mock GitHub to return CONFLICTING status
        with patch(GITHUB_PATCH_PATH) as mock_github_class:
            mock_github = mock_github_class.return_value
            mock_pr_info = Mock()
            mock_pr_info.pr_number = 123
            mock_pr_info.url = "https://github.com/org/repo/pull/123"
            mock_github.get_pr_status.return_value = mock_pr_info

            mock_mergeability = Mock()
            mock_mergeability.mergeable = "CONFLICTING"
            mock_mergeability.merge_state_status = "DIRTY"
            mock_github.get_pr_mergeability.return_value = mock_mergeability

            result = execute_pre_analysis(ops)

        # Assert: Should return error, no commits made
        assert isinstance(result, PreAnalysisError)
        assert result.error_type == "pr_has_conflicts"
        assert "conflicts" in result.message.lower()
        assert result.details["pr_number"] == "123"
        assert result.details["parent_branch"] == "master"

    def test_pre_analysis_proceeds_when_no_conflicts(self) -> None:
        """Test that workflow proceeds normally when no conflicts exist."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="master").with_commits(1)

        # Mock GitHub to return MERGEABLE status
        with patch(GITHUB_PATCH_PATH) as mock_github_class:
            mock_github = mock_github_class.return_value
            mock_pr_info = Mock()
            mock_pr_info.pr_number = 123
            mock_pr_info.url = "https://github.com/org/repo/pull/123"
            mock_github.get_pr_status.return_value = mock_pr_info

            mock_mergeability = Mock()
            mock_mergeability.mergeable = "MERGEABLE"
            mock_mergeability.merge_state_status = "CLEAN"
            mock_github.get_pr_mergeability.return_value = mock_mergeability

            result = execute_pre_analysis(ops)

        # Assert: Should succeed
        assert isinstance(result, PreAnalysisResult)
        assert result.success is True

    def test_pre_analysis_fallback_to_git_merge_tree(self) -> None:
        """Test fallback to git merge-tree when no PR exists."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="master").with_commits(1)
        # Configure fake to simulate conflict
        ops.git().simulate_conflict("master", "feature-branch")

        # Mock GitHub to return no PR
        with patch(GITHUB_PATCH_PATH) as mock_github_class:
            mock_github = mock_github_class.return_value
            mock_pr_info = Mock()
            mock_pr_info.pr_number = None
            mock_pr_info.url = None
            mock_github.get_pr_status.return_value = mock_pr_info

            result = execute_pre_analysis(ops)

        # Assert: Should detect conflict via git merge-tree
        assert isinstance(result, PreAnalysisError)
        assert result.error_type == "pr_has_conflicts"
        assert result.details["detection_method"] == "git_merge_tree"

    def test_pre_analysis_proceeds_on_unknown_mergeability(self) -> None:
        """Test that UNKNOWN mergeability doesn't block workflow."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="master").with_commits(1)

        # Mock GitHub to return UNKNOWN status
        with patch(GITHUB_PATCH_PATH) as mock_github_class:
            mock_github = mock_github_class.return_value
            mock_pr_info = Mock()
            mock_pr_info.pr_number = 123
            mock_pr_info.url = "https://github.com/org/repo/pull/123"
            mock_github.get_pr_status.return_value = mock_pr_info

            mock_mergeability = Mock()
            mock_mergeability.mergeable = "UNKNOWN"
            mock_mergeability.merge_state_status = "UNKNOWN"
            mock_github.get_pr_mergeability.return_value = mock_mergeability

            result = execute_pre_analysis(ops)

        # Assert: Should proceed with warning
        assert isinstance(result, PreAnalysisResult)
        assert result.success is True


class TestPostAnalysisExecution:
    """Tests for post-analysis phase execution logic."""

    @patch("erk.data.kits.gt.kit_cli_commands.gt.submit_branch.time.sleep")
    def test_post_analysis_creates_pr(self, mock_sleep: Mock) -> None:
        """Test successfully creating new PR."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="main").with_commits(1)
        # No PR initially (will be created)

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        assert result.branch_name == "feature-branch"
        # PR created but number not retrieved in this flow
        assert "PR created (number pending)" in result.message
        # Verify sleep was called 4 times (5 attempts, no sleep after last)
        assert mock_sleep.call_count == 4

    def test_post_analysis_updates_existing_pr(self) -> None:
        """Test successfully updating existing PR metadata."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(123, url="https://github.com/repo/pull/123")
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        assert result.pr_number == 123
        assert result.pr_url == "https://github.com/repo/pull/123"
        assert "Updated PR #123" in result.message

    def test_post_analysis_amend_fails(self) -> None:
        """Test error when git commit --amend fails."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="main")
        # No commits, so amend will fail

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "amend_failed"
        assert "Failed to amend commit" in result.message

    def test_post_analysis_submit_fails_generic(self) -> None:
        """Test error on generic submit failure."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_failure(stdout="", stderr="generic error")
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "submit_failed"
        assert "Failed to submit branch" in result.message

    def test_post_analysis_submit_fails_merged_parent(self) -> None:
        """Test error when parent branches merged but not in main trunk."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_failure(
                stdout="",
                stderr="merged but the merged commits are not contained in the main trunk",
            )
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "submit_merged_parent"
        assert "Parent branches have been merged" in result.message

    def test_post_analysis_detects_submit_conflict(self) -> None:
        """Test that submit conflicts are detected and reported correctly."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_failure(
                stdout="",
                stderr=(
                    "error: could not rebase\nCONFLICT (content): Merge conflict in src/main.py"
                ),
            )
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "submit_conflict"
        assert "Merge conflicts detected during branch submission" in result.message
        stderr = result.details["stderr"]
        assert isinstance(stderr, str)
        assert "CONFLICT" in stderr

    def test_post_analysis_conflict_check_is_first(self) -> None:
        """Test that conflict detection happens before other error patterns."""
        # This tests that even if output contains other error patterns,
        # conflicts are detected first
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_failure(
                stdout="Branch updated remotely",  # Would normally trigger submit_diverged
                stderr="merge conflict in file.txt",  # But conflict should be detected first
            )
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.error_type == "submit_conflict"  # Not submit_diverged
        assert "Merge conflicts detected" in result.message

    def test_post_analysis_submit_fails_diverged(self) -> None:
        """Test error when branch has diverged from remote."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_failure(
                stdout="branch updated remotely, must sync",
                stderr="",
            )
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "submit_diverged"
        assert "Branch has diverged from remote" in result.message

    def test_post_analysis_submit_empty_parent(self) -> None:
        """Test error when parent branch is empty (already merged)."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_submit_success_but_nothing_submitted()
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisError)
        assert result.success is False
        assert result.error_type == "submit_empty_parent"
        assert "empty parent branch" in result.message.lower()
        assert "gt track" in result.message

    def test_post_analysis_pr_update_fails(self) -> None:
        """Test warning when gh pr edit fails (PR created with metadata, update optional)."""
        # Setup: branch with PR and PR update configured to fail
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(123)
            .with_pr_update_failure()  # Configure PR update to fail
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        # PR update failure is now treated as a warning, not an error
        # Metadata is already in the PR from commit, update is just to replace placeholder
        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        assert result.pr_number == 123
        assert "checkout command shows placeholder" in result.message

    @patch("erk.data.kits.gt.kit_cli_commands.gt.submit_branch.time.sleep")
    def test_post_analysis_pr_info_delayed(self, mock_sleep: Mock) -> None:
        """Test that PR metadata update succeeds even when PR info is delayed."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(123)
            .with_pr_delay(attempts_until_visible=2)  # PR appears on 3rd attempt
        )

        result = execute_post_analysis(
            commit_message="Add feature\n\nFull description",
            ops=ops,
        )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        assert result.pr_number == 123
        assert "Updated PR #123" in result.message
        # Verify sleep was called with expected delays
        assert mock_sleep.call_count == 2
        mock_sleep.assert_any_call(0.5)
        mock_sleep.assert_any_call(1.0)

    def test_post_analysis_commit_includes_metadata(self, tmp_path: Path) -> None:
        """Test that commit message includes metadata in initial amend (before gt submit)."""
        # Create .impl/issue.json in temp directory
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/repo/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}',
            encoding="utf-8",
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True

        # CRITICAL: Verify that amend_commit was called with metadata-inclusive message
        git_state = ops.git().get_state()
        assert len(git_state.commits) == 1
        commit_message = git_state.commits[0]

        # Commit message should contain metadata
        assert "This PR was generated by an agent in the `erk` queue." in commit_message
        assert "- **Plan:** [#123](https://github.com/repo/issues/123)" in commit_message
        assert "__PLACEHOLDER_PR_NUMBER__" in commit_message  # Placeholder initially
        assert "Closes #123" in commit_message
        assert "---" in commit_message
        # And it should also contain the AI body
        assert "Full description" in commit_message

    def test_post_analysis_with_issue_reference(self, tmp_path: Path) -> None:
        """Test that PR body includes metadata section when issue.json exists."""
        # Create .impl/issue.json in temp directory
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/repo/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}'
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        # Verify metadata section structure
        github_ops = ops.github()
        github_state = github_ops.get_state()
        assert github_state.pr_titles[456] == "Add feature"
        pr_body = github_state.pr_bodies[456]
        # Check metadata section components
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert "- **Plan:** [#123](https://github.com/repo/issues/123)" in pr_body
        assert "erk pr checkout 456" in pr_body
        assert "Closes #123" in pr_body
        assert "---" in pr_body
        assert "Full description" in pr_body

    def test_post_analysis_without_issue_reference(self, tmp_path: Path) -> None:
        """Test that PR body has no metadata section when no .impl/ metadata exists."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return temp directory without .impl/issue.json
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        # Verify that PR body has no metadata section (no agent-generated PR markers)
        github_ops = ops.github()
        github_state = github_ops.get_state()
        assert github_state.pr_titles[456] == "Add feature"
        pr_body = github_state.pr_bodies[456]
        # No metadata section when no .impl/ metadata exists
        assert "This PR was generated by an agent" not in pr_body
        assert "Closes #" not in pr_body
        # Body should just be the AI-generated content
        assert pr_body == "Full description"

    def test_post_analysis_with_issue_reference_empty_body(self, tmp_path: Path) -> None:
        """Test that PR body has metadata section when commit message has only title."""
        # Create .impl/issue.json in temp directory
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 789, "issue_url": "https://github.com/repo/issues/789", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}'
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            # Commit message with only title (no body)
            result = execute_post_analysis(
                commit_message="Add feature",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        # Verify metadata section structure (with empty AI body)
        github_ops = ops.github()
        github_state = github_ops.get_state()
        assert github_state.pr_titles[456] == "Add feature"
        pr_body = github_state.pr_bodies[456]
        # Check metadata section components
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert "- **Plan:** [#789](https://github.com/repo/issues/789)" in pr_body
        assert "erk pr checkout 456" in pr_body
        assert "Closes #789" in pr_body
        assert "---" in pr_body

    def test_post_analysis_with_plan_author(self, tmp_path: Path) -> None:
        """Test that PR body includes plan author in metadata when plan.md has created_by."""
        # Create .impl/plan.md with plan-header metadata block
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        plan_md = impl_dir / "plan.md"
        plan_md.write_text(
            """<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->
<!-- erk:metadata-block:plan-header -->
<details>
<summary><code>plan-header</code></summary>

```yaml

schema_version: '2'
created_at: '2025-01-15T10:00:00+00:00'
created_by: plan-author-user
worktree_name: test-worktree

```

</details>
<!-- /erk:metadata-block:plan-header -->

# Test Plan

1. Step one
""",
            encoding="utf-8",
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        # Verify metadata section includes plan author
        github_ops = ops.github()
        github_state = github_ops.get_state()
        assert github_state.pr_titles[456] == "Add feature"
        pr_body = github_state.pr_bodies[456]
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert "- **Plan Author:** @plan-author-user" in pr_body
        assert "Full description" in pr_body

    def test_post_analysis_with_issue_and_plan_author(self, tmp_path: Path) -> None:
        """Test that PR body includes both issue reference and plan author in metadata."""
        # Create .impl/issue.json
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/repo/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}'
        )

        # Create .impl/plan.md with plan-header metadata block
        plan_md = impl_dir / "plan.md"
        plan_md.write_text(
            """<!-- WARNING: Machine-generated. Manual edits may break erk tooling. -->
<!-- erk:metadata-block:plan-header -->
<details>
<summary><code>plan-header</code></summary>

```yaml

schema_version: '2'
created_at: '2025-01-15T10:00:00+00:00'
created_by: combined-author
worktree_name: test-worktree

```

</details>
<!-- /erk:metadata-block:plan-header -->

# Test Plan

1. Step one
""",
            encoding="utf-8",
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        github_ops = ops.github()
        github_state = github_ops.get_state()
        # Verify metadata section includes both issue and author
        pr_body = github_state.pr_bodies[456]
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert "- **Plan:** [#123](https://github.com/repo/issues/123)" in pr_body
        assert "- **Plan Author:** @combined-author" in pr_body
        assert "Closes #123" in pr_body
        assert "Full description" in pr_body
        # Metadata should come before AI-generated content
        assert pr_body.index("---") < pr_body.index("Full description")

    def test_post_analysis_with_github_actions_run_link(self, tmp_path: Path) -> None:
        """Test that PR body includes GitHub Action link in metadata when run-info.json exists."""
        # Create .impl/issue.json
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/dagster-io/erk/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}'
        )

        # Create .impl/run-info.json with run URL
        run_info_json = impl_dir / "run-info.json"
        run_info_json.write_text(
            '{"run_id": "12345678901", '
            '"run_url": "https://github.com/dagster-io/erk/actions/runs/12345678901"}'
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        github_ops = ops.github()
        github_state = github_ops.get_state()
        pr_body = github_state.pr_bodies[456]
        # Should include run link in metadata section
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert (
            "- **GitHub Action:** [View Run]"
            "(https://github.com/dagster-io/erk/actions/runs/12345678901)" in pr_body
        )

    def test_post_analysis_no_run_link_when_no_run_info(self, tmp_path: Path) -> None:
        """Test that PR body has no GitHub Action link when run-info.json is missing."""
        # Create .impl/issue.json only (no run-info.json)
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        issue_json = impl_dir / "issue.json"
        issue_json.write_text(
            '{"issue_number": 123, "issue_url": "https://github.com/dagster-io/erk/issues/123", '
            '"created_at": "2025-01-01T00:00:00Z", "synced_at": "2025-01-01T00:00:00Z"}'
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        github_ops = ops.github()
        github_state = github_ops.get_state()
        pr_body = github_state.pr_bodies[456]
        # Should NOT include GitHub Action link when run-info.json is missing
        assert "GitHub Action" not in pr_body
        # But should still have other metadata
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert "- **Plan:** [#123]" in pr_body

    def test_post_analysis_run_link_works_without_issue_reference(self, tmp_path: Path) -> None:
        """Test that PR body includes GitHub Action link even without issue reference."""
        # Create .impl/run-info.json with run URL (no issue.json)
        impl_dir = tmp_path / ".impl"
        impl_dir.mkdir()
        run_info_json = impl_dir / "run-info.json"
        run_info_json.write_text(
            '{"run_id": "12345678901", '
            '"run_url": "https://github.com/dagster-io/erk/actions/runs/12345678901"}'
        )

        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(456, url="https://github.com/repo/pull/456")
        )

        # Mock Path.cwd() to return our temp directory
        patch_path = "erk.data.kits.gt.kit_cli_commands.gt.submit_branch.Path.cwd"
        with patch(patch_path) as mock_cwd:
            mock_cwd.return_value = tmp_path

            result = execute_post_analysis(
                commit_message="Add feature\n\nFull description",
                ops=ops,
            )

        assert isinstance(result, PostAnalysisResult)
        assert result.success is True
        github_ops = ops.github()
        github_state = github_ops.get_state()
        pr_body = github_state.pr_bodies[456]
        # Should include GitHub Action link (run_url from run-info.json)
        assert "This PR was generated by an agent in the `erk` queue." in pr_body
        assert (
            "- **GitHub Action:** [View Run]"
            "(https://github.com/dagster-io/erk/actions/runs/12345678901)" in pr_body
        )
        # Should NOT have Plan link (no issue.json) or Closes line
        assert "- **Plan:**" not in pr_body
        assert "Closes #" not in pr_body


class TestSubmitBranchCLI:
    """Tests for submit_branch CLI commands."""

    def test_pre_analysis_command_success(self, runner: CliRunner) -> None:
        """Test pre-analysis CLI command with successful execution."""
        ops = FakeGtKitOps().with_branch("feature-branch", parent="main").with_commits(1)

        # Monkey patch execute_pre_analysis to use our fake ops
        import erk.data.kits.gt.kit_cli_commands.gt.submit_branch as submit_module

        original_execute = submit_module.execute_pre_analysis

        def patched_execute(ops_param: object | None = None) -> object:
            return original_execute(ops)

        submit_module.execute_pre_analysis = patched_execute

        try:
            result = runner.invoke(submit_pr, ["pre-analysis"])

            assert result.exit_code == 0
            output = json.loads(result.output)
            assert output["success"] is True
            assert output["branch_name"] == "feature-branch"
            assert output["commit_count"] == 1
        finally:
            submit_module.execute_pre_analysis = original_execute

    def test_post_analysis_command_success(self, runner: CliRunner) -> None:
        """Test post-analysis CLI command with successful execution."""
        ops = (
            FakeGtKitOps()
            .with_branch("feature-branch", parent="main")
            .with_commits(1)
            .with_pr(123, url="https://github.com/repo/pull/123")
        )

        # Monkey patch execute_post_analysis to use our fake ops
        import erk.data.kits.gt.kit_cli_commands.gt.submit_branch as submit_module

        original_execute = submit_module.execute_post_analysis

        def patched_execute(commit_message: str, ops_param: object | None = None) -> object:
            return original_execute(commit_message, ops)

        submit_module.execute_post_analysis = patched_execute

        try:
            result = runner.invoke(
                submit_pr,
                [
                    "post-analysis",
                    "--commit-message",
                    "Add feature\n\nDescription",
                ],
            )

            assert result.exit_code == 0
            # Parse JSON from output (may contain progress messages and multi-line JSON)
            # Find the JSON object by looking for { and matching }
            output_text = result.output
            json_start = output_text.find("{")
            assert json_start >= 0, f"No JSON object found in output: {output_text}"

            # Find matching closing brace
            brace_count = 0
            json_end = -1
            for i in range(json_start, len(output_text)):
                if output_text[i] == "{":
                    brace_count += 1
                elif output_text[i] == "}":
                    brace_count -= 1
                    if brace_count == 0:
                        json_end = i + 1
                        break

            assert json_end > json_start, f"No complete JSON object in output: {output_text}"
            json_text = output_text[json_start:json_end]
            output = json.loads(json_text)
            assert output["success"] is True
            assert output["pr_number"] == 123
        finally:
            submit_module.execute_post_analysis = original_execute
